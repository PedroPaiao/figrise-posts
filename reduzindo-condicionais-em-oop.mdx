---
title: "Reduzindo condicionais em Linguagens Orientadas a Objetos (Ruby)"
date: "2024-01-20"
tags: ["ruby"]
---

### Introdu√ß√£o üöÄ

Um assunto muito abordado quando estamos come√ßando nossa carreira, √© a tal da "logica proposicional", os famosos `if's` `else's` que tanto amamos e utilizamos para solucionar tanto problemas simples quanto complexos. E uma das maiores dificultades que enfratamos nessa hora, √© como reduzir ao maximo o numero e a complexidade das condicionais que estamos usando.

#### Felizmente existe a Orienta√ß√£o a Objetos üòÅ

### O que s√£o objetos?üí°

Para entendimento geral vamos adotar um objeto, como toda instancia que possui uma classe de defini√ß√£o, hoje a maior parte das linguagens modernas aceitam Orienta√ß√£o a Objetos, mesmo que n√£o seja o paradigma original ou mais usado.

### Vamos ao exemplo pratico

N√≥s fomos contrados para desenvolver um sistema que abriga animais, e a unica coisa que foi solicitado √© que seja possivel retornar o tipo do animal e quantas refei√ß√µes ele precisa, ent√£o n√≥s resolvemos implementar a classe `Animal`, que √© composta pelo atributo `kind`, `id` e pelo metodo `meals`

```ruby
class  Animal
  attr_reader  :kind

  def  initialize(kind:)
   @kind =  kind
  end

  def meals
    puts  "Needs 2 meals"
  end
end

```

Agora podemos instanciar um `objeto` da classe `Animal`, e chamar o metodo `meals` que ir√° nos exibir a mensagem `Needs 2 meals`

```ruby
dog =  Animal.new(kind: "dog")
dog.meals
>>>  "Needs 2 meals"
```

Muito bem! Agora chegou mais uma tarefa, precisamos especializar o metodo `meals` para retornar o numero de refei√ß√µes que esse animal precisa dependendo do `kind` dele. Ent√£o tivemos a `brilhante` ideia de fazer uma condicional baseando no atributo `kind`

```ruby
class  Animal
  ...
  def meals
    if name == "dog"
      "Needs 3 meals"
    else if name == "bird"
      "Needs 2 meals"
    end
  end
end
```

Muito bem! N√≥s atendemos nosso problema, por√©m ja conseguimos sentir uma certa dificuldade com mais animais, vamos precisar de 15 `ifs` se continuarmos assim ü§£ü§£

### Great times are coming!

Bom, j√° entendemos que objetos tem implementa√ß√µes diferentes, e que eles possuem metodos especificos para cada implementa√ß√£o, sendo assim vamos usar essa capacidade para remover `todos` os `ifs` desse nosso problema.

Apenas para exemplificar, vamos implementar uma classe chamada `Dog` e uma chamada `Bird`

```ruby
class Dog
  def meals
    "Needs 2 meals"
  end
end
```

```ruby
class Bird
  def meals
    "Needs 1 meal"
  end
end
```

Agora vamos usar a magia da `Composi√ß√£o`, muito parecido com `Inje√ß√£o de dependencia`, para compor essa nova classe `Animal`

```ruby
class Animal
  attr_reader  :kind, :kind_klass

  def initialize(kind:, :kind_klass)
   @kind =  kind
   @kind_klass = kind_klass
  end

  def meals
    kind_klass.meals
  end
end
```

Otimo! Dessa forma n√£o precisamos mais nos preocupar com ifs, cada classe e cada `tipo` de animal ir√° se comportar como quiser, sem a necessidade de tratarmos na classe `Animal` j√° que ela mesmo pode ser varios animais diferentes!

```ruby
dog =  Animal.new(kind: "dog", kind_klass: Dog)
dog.meals
>>>  "Needs 2 meals"
```

### Bonus

Bom, e quando n√£o sabemos exatamente qual √© o animal? Talvez seu primeiro impulso seja fazer algo parecido com isso:

```ruby
class Animal
  attr_reader  :kind, :kind_klass

  def initialize(kind:, :kind_klass)
   @kind =  kind
   @kind_klass = kind_klass
  end

  def meals
    kind_klass&.meals || "Needs 1 meals"
  end
end

animal = Animal.new(kind: "Unknown", kind_klass: nil)
animal.meals
>>> "Needs 1 meals"
```

Resolve nosso problema, mas n√£o estavamos tentando fugir de condicionais? N√≥s j√° preparamos o terreno, ent√£o vamos apenas nos aproveitar de ter feito uma boa arquitetura!

```ruby
class DefaultAnimal
  def meals
    "Needs 1 meals"
  end
end

class Animal
  attr_reader  :kind, :kind_klass

  def initialize(kind:, kind_klass: DefaultAnimal)
   @kind =  kind
   @kind_klass = kind_klass
  end

  def meals
    kind_klass.meals
  end
end

animal = Animal.new(kind: "Unknown")
animal.meals
>>> "Needs 1 meals"
```

Dessa forma n√≥s j√° temos um `fallback` para caso o ususario n√£o saiba qual animal √©, ou caso ainda n√£o exista uma classe implementada pra ele.
