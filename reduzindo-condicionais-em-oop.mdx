---
title: "Reduzindo condicionais em Linguagens Orientadas a Objetos (Ruby)"
date: "2024-01-20"
tags: ["ruby"]
---

### IntroduÃ§Ã£o ğŸš€

Um assunto muito abordado quando estamos comeÃ§ando nossa carreira, Ã© a tal da "logica proposicional", os famosos `if's` `else's` que amamos e utilizamos para solucionar problemas simples e complexos. E uma das maiores dificultades que enfrentamos nessa hora, Ã© como reduzir ao maximo o numero e a complexidade de condicionais.

#### Felizmente existe a OrientaÃ§Ã£o a Objetos ğŸ˜

### O que sÃ£o objetos?ğŸ’¡

Para entendimento geral vamos adotar um objeto, como toda instancia que possui uma classe de definiÃ§Ã£o, hoje a maior parte das linguagens modernas aceitam OrientaÃ§Ã£o a Objetos, mesmo que nÃ£o seja o paradigma original ou mais usado.

### Vamos ao exemplo pratico

NÃ³s fomos contrados para desenvolver um sistema que abriga animais, e a unica coisa que foi solicitado Ã© que seja possivel retornar o tipo do animal e quantas refeiÃ§Ãµes ele precisa, entÃ£o nÃ³s resolvemos implementar a classe `Animal`, que Ã© composta pelo atributo `kind`, `id` e pelo metodo `meals`

```ruby
class  Animal
  attr_reader  :kind

  def  initialize(kind:)
   @kind =  kind
  end

  def meals
    puts  "Needs 2 meals"
  end
end

```

Agora podemos instanciar um `objeto` da classe `Animal`, e chamar o metodo `meals` que irÃ¡ nos exibir a mensagem `Needs 2 meals`

```ruby
dog =  Animal.new(kind: "dog")
dog.meals
>>>  "Needs 2 meals"
```

Muito bem! Agora chegou mais uma tarefa, precisamos especializar o metodo `meals` para retornar o numero de refeiÃ§Ãµes que esse animal precisa dependendo do `kind` dele. EntÃ£o tivemos a `brilhante` ideia de fazer uma condicional utilizando o atributo `kind`

```ruby
class  Animal
  ...
  def meals
    if kind == "dog"
      puts "Needs 3 meals"
    elsif kind == "bird"
      puts "Needs 2 meals"
    end
  end
end
```

Muito bem! NÃ³s atendemos nosso problema, porÃ©m ja conseguimos sentir uma certa dificuldade com mais animais, vamos precisar de 15 `ifs` se continuarmos assim ğŸ¤£ğŸ¤£

### Great times are coming!

Bom, jÃ¡ entendemos que objetos tem implementaÃ§Ãµes diferentes, e que eles possuem metodos especificos para cada implementaÃ§Ã£o, sendo assim vamos usar essa capacidade para remover `todos` os `ifs` desse nosso problema.

Apenas para exemplificar, vamos implementar uma classe chamada `Dog` e uma chamada `Bird`

```ruby
class Dog
  def meals
    "Needs 2 meals"
  end
end
```

```ruby
class Bird
  def meals
    "Needs 1 meal"
  end
end
```

Agora vamos usar a magia da `ComposiÃ§Ã£o`, muito parecido com `InjeÃ§Ã£o de dependencia`, para compor essa nova classe `Animal`

```ruby
class Animal
  attr_reader  :kind, :kind_klass

  def initialize(kind:, kind_klass:)
   @kind =  kind
   @kind_klass = kind_klass.new
  end

  def meals
    puts kind_klass.meals
  end
end
```

Otimo! Dessa forma nÃ£o precisamos mais nos preocupar com ifs, cada classe e cada `tipo` de animal irÃ¡ se comportar como quiser, sem a necessidade de tratarmos na classe `Animal` jÃ¡ que ela mesmo pode ser varios animais diferentes!

```ruby
dog =  Animal.new(kind: "dog", kind_klass: Dog)
dog.meals
>>>  "Needs 2 meals"
```

### Bonus

Bom, e quando nÃ£o sabemos exatamente qual Ã© o animal? Talvez seu primeiro impulso seja fazer algo parecido com isso:

```ruby
class Animal
  attr_reader  :kind, :kind_klass

  def initialize(kind:, kind_klass:)
   @kind =  kind
   @kind_klass = kind_klass.new
  end

  def meals
    if kind_klass
      puts kind_klass.meals
    else
      puts "Needs 1 meals"
    end
  end
end

animal = Animal.new(kind: "Unknown", kind_klass: nil)
animal.meals
>>> "Needs 1 meals"
```

Resolve nosso problema, mas nÃ£o estavamos tentando fugir de condicionais? NÃ³s jÃ¡ preparamos o terreno, entÃ£o vamos apenas nos aproveitar de ter feito uma boa arquitetura!

```ruby
class DefaultAnimal
  def meals
    "Needs 1 meals"
  end
end

class Animal
  attr_reader  :kind, :kind_klass

  def initialize(kind:, kind_klass: DefaultAnimal)
   @kind =  kind
   @kind_klass = kind_klass.new
  end

  def meals
    kind_klass.meals
  end
end

animal = Animal.new(kind: "Unknown")
animal.meals
>>> "Needs 1 meals"
```

Dessa forma nÃ³s jÃ¡ temos um `fallback` para caso o usuario nÃ£o saiba qual animal Ã©, ou caso ainda nÃ£o exista uma classe implementada pra ele.

Obrigado pela atenÃ§Ã£o e espero ter ajudado! ğŸ‘